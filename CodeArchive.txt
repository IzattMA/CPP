
Pointers
int* ptr;
int var=7; 	//#0xA
int foo = 21; 	//0xB
ptr = &var;	//0xA
ptr = &foo;	//0xB

Reference
int& ref = var;	//7

ptr = &var;	//0xA
ptr = &ref;	//0xA also


Pass by value, pass by reference, pass by pointer
https://www.youtube.com/watch?v=UWYnUGnChhA


#include <stdio.h>

void passByVal(int val);
void passByRef(int &val);
void passByPtr(int *ptr);


int main(){

	int x = 5;
	printf("x = %i\n",x);
	
	passByValue(x);
	printf("x = %i\n",x);	//5	

	passByRef(x);
	printf("x = %i\n",x);	//20	

	//Pass by pointer is like pass by reference, but syntax is different
	int* xptr = &x;		//pointers hold addresses
	
	printf("x = %i\n",x);		//5
	printf("*ptr = %i\n",*xptr);	//5
	passByPtr(xptr);
	printf("x = %i\n",x);		//30
	printf("*ptr = %i\n",*xptr);	//30
	
	
	return 0;

}

void passByVal(int val){

	val = 10;
	printf("val = %i\n",val);

}

void passByRef(int &val){

	ref = 20;
	printf("ref = %i\n",ref);

}


void passByPtr(int *ptr){

	*ptr = 30;
	printf("*ptr = %i\n",*ptr);

}

================================================================================

========== Pointers ==========

int num = 3;

int* pNum = &num;

int *pNum = &num;

=====

 #include "stdafx.h"
 #include <iostream>
    
    using namespace std;
    
    int main()
    {
    
        int num = 3;
        int *pNum = &num;

        cout << pNum << endl;

        return 0;
    }

=====

int *pNum;  // not recommended
    
cout << pNum << endl;

=====



========== Dereference Operator =========

int num = 3;            // a simple variable holding the value 3
int *pNum = &num;        // a pointer holding the address of num
cout << pNum << endl;    // output the memory address of num
cout << *pNum << endl;    // output the value 3


=====

int num = 3;
int *pNum = &num;
cout << pNum << endl;
cout << *pNum << endl;

*pNum = 45;
cout << *pNum << endl;		//45
cout << num << endl;		//45



========== 2018_02_10_1249_EdXCPP_PointDereference.cpp ==========

// 2018_02_10_1249_EdXCPP_PointDereference.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream>

using namespace std;

int main()
{
    
	int num = 3;
	int *pNum = &num;
	cout << pNum << endl;		//hex
	cout << *pNum << endl;		//3

	*pNum = 45;
	cout << *pNum << endl;		//45
	cout << num << endl;		//45

}


========================================================================================================================

==========  2018_02_10_1254_EdXCPP_SimplePointersDemo.cpp  ===========


// 2018_02_10_1254_EdXCPP_SimplePointersDemo.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <iostream>

int main()
{

	/********************
	* simple pointers   *
	*********************/

	int num = 3;

	// create a pointer variable to an int type and assign it the address of the integer straight-away
	int *pNum = &num;

	// output the value of num
	std::cout << num << std::endl;		//3

	// output the address of num to compare with the value in pNum
	std::cout << &num << std::endl;		//hex

	// output the value stored in pNUm
	std::cout << *pNum << std::endl;	//3


}


==========  Understanding pointers better ==============================================================================

int ~ 32-bit value

int *pNum = &num;

Same answer
-----------
cout << pNum;
cout << &num;


cout << num //3
int contents = *pNUM;

int *pNum = &num; 		//left of assignment means pointer
int contents = *pNum; 		//right of assignment means dereference operator

==========
========== Introducing reference types =================================================================================

int num = 3;
int &refNum = num;
int &refNum2;
cout << refNum << endl;		//3

int num = 3;
int &refNum = num;

cout << "num contains " << num << endl;			//num contains 3
cout << "refNum contains " << refNum << endl;		//refNum contains 3

refNum++;    // increment refNum by 1

cout << "num contains " << num << endl;			//num contains 4			
cout << "refNum contains " << refNum << endl;		//refNum contains 4
cout << "refNum is located at " << &refNum << " and num is located at " << &num << endl;  	//refNum is located at <hex> 
												// and num located at <hex

==========

 using namespace std;

    void passByValue(int);

    int main()
    {

        int num = 3;
        cout << "In main()" << endl;
        cout << "Value of num is " << num << endl;

        passByValue(num);

        cout << "Back in main and the value of num is  " << num << endl;


        return 0;
    }

    void passByValue(int num1)
    {
        cout << "In passByValue()" << endl;
        cout << "Value of num1 is " << num1 << endl;

        // modify num1, won't impact num
        num1++;

        cout << "num1 is now " << num1 << endl;
    }

==========

// Pass by value

#include "stdafx.h"
#include <iostream>
using namespace std;

void passByValue(int);

int main()
{

	int num = 3;
	cout << "In main()" << endl;
	cout << "Value of num is " << num << endl;

	passByValue(num);

	cout << "Back in main and the value of num is  " << num << endl;


	return 0;
}

void passByValue(int num1)
{
	cout << "In passByValue()" << endl;
	cout << "Value of num1 is " << num1 << endl;

	// modify num1, won't impact num
	num1++;

	cout << "num1 is now " << num1 << endl;
}


========================================================================================================================

// Pass by reference

#include "stdafx.h"
#include <iostream>
using namespace std;

void passByRef(int &num1);  //required else raises a passByRef error

int main()
{

	int num = 3;
	cout << "In main()" << endl;
	cout << "Value of num is " << num << endl;

	passByRef(num);

	cout << "Back in main and the value of num is  " << num << endl;


	return 0;
}

void passByRef(int &num1)
{
	cout << "In passByRef()" << endl;
	cout << "Value of num1 is " << num1 << endl;

	// modify num1 which will now change num
	num1++;

	cout << "num1 is now " << num1 << endl;
}



========================================================================================================================
00F21338
Non-object data types
non-object data types, like int, double, bool -> stack.

Stack is reclaimed when variables go out of scope


========================================================================================================================


// declare a pointer to int and allocate space for it
// with the keyword new
    int *pInt = new int; 

// declare a pointer to double and allocate space for it
// with the keyword new
    double * pDouble = new double;

// store the value 3 in the memory location
// pointed to by pInt
    *pInt = 3; 

// store the value 5.0 in the memory location
// pointed to by pDouble
    *pDouble = 5.0;

C++ Data Types
--------------

*pointer	4 bytes 
int 		4 bytes [00F1FBA8, 00F1FBAC] = 4 bytes
double		8 bytes [00F21330, 00F21338] = 8 bytes


// declare a pointer to int and allocate space for it
// with the keyword new
   int *pInt = new int; 

// declare a pointer to double and allocate space for it
// with the keyword new
   double * pDouble = new double;

// store the value 3 in the memory location
// pointed to by pInt
   *pInt = 3; 

// store the value 5.0 in the memory location
// pointed to by pDouble
   *pDouble = 5.0;

   delete pInt;
   delte pDouble;



=====================================================================
class Person{

private:

std::string firstname;
std::string lastname;

int age;


public:

Person();

Person(std::string fName, std::string lName);

Person(std::string fName, std::string lName, int age);

~Person();

void SetFirstName(std::string fName);
std::string GetFirstName();

void SetLastName(std::string lname);
std::string GetLastName();

void SetAge(int age);
int GetAge();

void SayHello();

};
===================================================
#include "stdafx.h"
#include "Person.h"
#include <iostream>

Person::Person(){}

Person::Person(std::string fName, std::string lName){
	firstName = fName;
	lastName = lName;
}

Person::Person(std::string fName, std::string lName, int age){
	firstName = fName;
	lastName = lName;

	age = age;
}

Person::~Person(){

	std::cout << "Person destructor called " << std::endl;	

}


void Person::SetFirstName(std::string fName){
	this->firstName = fName;	

}

std::string Person::GetFirstName(){

	return this->firstName;
}


void Person::SetLastName(std::string lName){

	this->lastName = lName;
	
}

void Person::SetAge(int age){

	this->age = age;

}
=====================================================================
#include "stdafx.h"
#include "Person.h"
#include <iostream>
#inclde <string>


int main(){

	Person *pOne = new Person("Tom","Thumb",25);

	std::cout << "First name of pOne = " << pOne->GetFirstName() << std::endl;

	std::cout << "Memory address of pOne = "  << &pOne << std::endl;

	delete pOne;

	return 0;
}
===================================================

&refVariable = variable
You create an alias for a variable by using a reference type. A reference type is declared and assigned by using &refVariable = variable


========================================================================================================================
Lab 1

// https://courses.edx.org/courses/course-v1:Microsoft+DEV210.2x+3T2016/info



/*
1. Create a new C++ console application called PointersLab



2. In your main() function, create two variables. One variable needs to be an intrinsic integer variable named num1 and 
    
the second needs to be a pointer to an int pNum.



3. Assign the value 3 to num1.



4. Assign the value 5 to the memory location stored in pNum.  
   (Hint, there is a special operator used for this)



5. Create a function called PassByValue that accepts an integer argument.



6. Inside PassByValue, output a text string indicating the name of the function you are in.



7. Call PassByValue and pass in num1 as the argument.



8. Modify the value of num1 inside the PassByValue function and output the new value to the console window.



9. After the call returns to main(), output the value of num1 to the console window again.



10. Create a function called PassByRef that accepts a reference variable as an argument



11. Call PassByRef and send pNum as the argument.



12. Output a statement indicating the current function name.



13. Modify the value of pNum, setting it to 50,  and output the value to the console.



14. After the call returns to main(), output the value of pNum to the console.



*/



#include <iostream>



void PassByValue(int value) {
    

value = 8;
    

std::cout << value << std::endl;


}



void PassByRef(int* ref) {
    

*ref = 50;
    

std::cout << "PassByRef();" << std::endl;
}



/* 



2. In your main() function, create two variables.  
One variable needs to be an intrinsic integer variable named num1 
and 
the second needs to be a pointer to an int pNum.

3. Assign the value 3 to num

1.

4. Assign the value 5 to the memory location stored in pNum.  
(Hint, there is a special operator used for this)

*/

int main(int argc, char* argv[]) {
    
    int num1;
    int num2 = 0;
    int* pNum = &num2;
    
    num1 = 3;
    *pNum = 5;
    
    PassByValue(num1);
    std::cout << num1 << std::endl;

    PassByRef(pNum);
    std::cout << *pNum << std::endl;

// 15. Call PassByValue and pass in pNum as an argument.

    PassByValue(pNum);
    
// 16. Document any error messages for the lab assessment that might occur during your lab.

    return 0;
}






========================================================================================================================

Lab Requirements

x Create a new C++ console application called PointersLab

x In your main() function, create two variables.  One variable needs to be an intrinsic integer variable named num1 and the second needs to be a pointer to an int variable that you will call pNum.  (Note, pNum should NOT be a pointer to num1 which means you need to create another variable for pNum to point to.)

x Assign the value 3 to num1.

x Assign the value 5 to the memory location stored in pNum.  (Hint, there is a special operator used for this)

x Create a function called PassByValue that accepts an integer argument.

x Inside PassByValue, output a text string indicating the name of the function you are in.

x Call PassByValue and pass in num1 as the argument.

x Modify the value of num1 inside the PassByValue function and output the new value to the console window.

x After the call returns to main(), output the value of num1 to the console window again.

x Create a function called PassByRef that accepts a reference variable as an argument

x Call PassByRef and send pNum as the argument.

X Output a statement indicating the current function name.

x Modify the value of pNum, setting it to 50,  and output the value to the console.

x After the call returns to main(), output the value of pNum to the console.

x Call PassByValue and pass in pNum as an argument.

x Document any error messages for the lab assessment that might occur during your lab.

 - cannot convert arg from int* to int


x Create a pointer variable to a double, and allocate memory for it using the new keyword.

x Assign a value to the memory location.

x Use the dereference operator, get the value and output it to the console.

x Deallocate the memory for that variable.

x Output the value stored in the memory location for that variable again.

x Document any errors experienced for the lab assessment.

x Create a simple class in your C++ application called Person.

# Give Person member variables for name, age, height, and weight.  Feel free to make these private with public accessors or make them public without accessors.  It is not important for this exercise.

x Create a function in your application called ModifyPerson() that accepts a Person object as an argument.  NOTE: This function should be in the application area and not inside the Person class.

x Instantiate a Person object in your main() method and assign values to the member variables.

x Output the values stored in the member variables to the console window

x Call the ModifyPerson() function, passing in your Person object you just created.

x Inside the ModifyPerson() function, change the value in the name member variable.

x Back in main(), output the values stored in the Person object you created.  Did the name change?  It should have if you passed the object correctly to the function.

Close Visual Studio and take the lab assessment.


Unhandled exception because of deleted pointer

========================================================================================================================

git rm -r 2018_02_14_0830_EdXCPP_DynamicMemoryAllocationClasses

git commit -m "Delete duplicate project that was timestamped AM no PM"

========================================================================================================================

Math.h

    // Math.h
    // Header file for the Math class

    #pragma once

    // Math class definition
    static class Math
    {
        public:

        // given base and exponent, calculate value
        static int Math::pow(int base, int exp);

    };



========================================================================================================================

static, it is an indicator that we do not have to instantiate the class to use it in our program. 

In order to call the function from a static class, the function must also be static.

If static, need not instantiate the class

Math math = new Math();
math.pow(2, 8);


========================================================================================================================

Math.cpp

    #include "stdafx.h"
    #include "Math.h"

    int Math::pow(int base, int exp)
    {
        int result = 1;

        for (int i = 0; i < exp; i++)
        {
            result = result * base;
        }

        return result;
    }

MathTest.cpp

    // MathTest.cpp : Defines the entry point for the console application.
    //

    #include "stdafx.h"
    #include "Math.h"
    #include <iostream>

    using namespace std;

    int main()
    {
        int result = Math::pow(2, 10);
    
        cout << result << endl;

        return 0;
    }


scope resolution operator (::).  
required to call static members of a class.  
========================================================================================================================

**Person.h**

    #pragma once
    
    #include <string>
    
    class Person
    {
    
    private:
        std::string firstName;
        std::string lastName;
    
        int age;
    
    public:
        Person();
    
        Person(std::string fName, std::string lName);
    
        Person(std::string fName, std::string lName, int age);
    
        ~Person();

        void SayHello();
    };

**Person.cpp**


    #include "stdafx.h"
    #include "Person.h"
    #include <iostream>
    
    Person::Person()
    {
    
    }
    
    Person::Person(std::string fName, std::string lName)
    {
        firstName = fName;
        lastName = lName;
    }
    
    Person::Person(std::string fName, std::string lName, int age)
    {
        firstName = fName;
        lastName = lName;
    
        age = age;
    }
    
    
    Person::~Person()
    {
    }


 #include "stdafx.h"
    #include <iostream>
    #include "Person.h"
    
    using namespace std;
    
    int main()
    {
    
        // create a Person instance using default constructor
        Person *pOne = new Person();
        
        // Create a Person instance using 2 argument constructor
        Person *pTwo = new Person("Tom", "Thumb");
    
        // Create a Person instance using 3 argument constructor
        Person *pThree = new Person("Tom", "Thumb", 15);
    
    return 0;
    }





========================================================================================================================

Person *pOne = new Person(); //correct

Person per = new Person();  //incorrect

keyword "new" is used to allocate memory for an object at runtime

keyword "delete" is used to release that memory

Person *pOne = new Person("Gerry", "O\'Brien");

std::cout << pOne->GetLastName() << endl;

object has been dynamically allocated with the new keyword, we must use the arrow selection operator

Person *pOne = new Person("Gerry", "O\'Brien");
std::cout << pOne->GetLastName() << endl;


// delete object, releasing memory
delete pOne;



========================================================================================================================
Encapsulation

**Person.h**

    #pragma once

    #include <string>

    class Person
    {

    private:
        std::string firstName;
        std::string lastName;

        int age;

    public:

        int count;
        Person();

        Person(std::string fName, std::string lName);

        Person(std::string fName, std::string lName, int age);

        ~Person();

        void SetFirstName(std::string fName);
        std::string GetFirstName();
        
        void SetLastName(std::string lName);
        std::string GetLastName();

        void SetAge(int age);
        int GetAge();

        void SayHello();

};

**Person.cpp**

    #include "stdafx.h"
    #include "Person.h"
    #include <iostream>


    Person::Person()
    {
    
    }

    Person::Person(std::string fName, std::string lName)
    {
        firstName = fName;
        lastName = lName;
    }

    Person::Person(std::string fName, std::string lName, int age)
    {
        firstName = fName;
        lastName = lName;
    
        age = age;
    }


    Person::~Person()
    {
    }

    void Person::SetFirstName(std::string fName)
    {
        this->firstName = fName;
    }

    std::string Person::GetFirstName()
    {
        return this->firstName;
    }

    void Person::SetLastName(std::string lName)
    {
        this->lastName = lName;
    }

    std::string Person::GetLastName()
    {
        return this->lastName;
    }

    void Person::SetAge(int age)
    {
        if (age > 0)
        {
            this->age = age;
        }
        else
        {
            std::cout << "Please enter a valid age" << std::endl;
        }
    }

    int Person::GetAge()
    {
        return this->age;
    }

    void Person::SayHello()
    {
        std::cout << "Hello" << std::endl;
    }

**Test Program**

    int main()
    {
        Person p;

        p.SetFirstName("Gerry");
        std::cout << p.GetFirstName() << std::endl;

        // this line will output an invalid age message due to the 
        // validation check in the SetAge() function
        p.SetAge(-5);
    
        // this line will not work because firstName is private
        p.firstName = "Gerry";

        return 0;
    }




========================================================================================================================


:: scope resolution operator 


using namespace std;
    
    int main()
    {
        cout << "std version of cout";
        
        myNS::cout << "myNS version of cout";
    }


======

namespace Microsoft
    {
        namespace Geometry
        {
            const double PI = 3.14159;
    
            double Area(double radius)
            {
                return PI*(r*r);
            }
        }
        
    }


**Example with using statement**

    using namespace Microsoft;

    int main()
    {

        double radius = 12.5;

        double area = Geometry::Area(radius);
    }



** Example with using statement**

    int main()
    {

        double radius = 12.5;

        double area = Microsoft::Geometry::Area(radius);
    }


========================================================================================================================

Student stud1;

What would be the value of the member variables of a Student object if you instantation stud1 with the above code?

Values will be initialized to default values for the data types

========================================================================================================================

// Inheritance.  Vehicle is the base class, Car is the derived class or sub class

class Vehicle
{

private:
string Make;
string Color;
...

};


class Car: Vehicle
{

// member list includes Make and Color
// other Car specific members would go here.

};


3 types
 - Public
 - Private
 - Protected

=====
Public inheritance describes how a derived class inherits all the member variables of a base
class, both private and public, but is only able to directly access the public members of the
base class.

============
**Person.h**
------------

#pragma once
#include <string>
	
class Person
{
	private:
		std::string 

		~Person();
		void SayHello();
};

============

=============
**Student.h**
-------------

#pragma once
#include "Person.h"

class Student : public Person

{
	public:
		Student();
		~Student();
};
=============

===============
**Student.cpp**
---------------
#include "stdafx.h"
#include "Student.h"

Student::Student()
{
}

Student::~Student()
{
}

// this line will cause a compiler error
firstName = "Tom";
=============


=============
**Main.cpp**
-------------

#include "stdafx.h"
#include "Person.h"
#include "Student.h"
int main()
{
Student student1;
// this line will generate a compiler error
student1.
=============


=====
========================================================================================================================
========================================================================================================================
========================================================================================================================
========================================================================================================================
========================================================================================================================
========================================================================================================================
========================================================================================================================
========================================================================================================================
========================================================================================================================